local type = type
local string_gmatch = string.gmatch
local log_info = log.info
local log_warning = log.warning
local tostring = tostring

Command = {}
ConVar = {}

local initial_config_loaded = false

local commands = {}

local default_convar_flags =
{
	ARCHIVE = true,
	LOCAL_ONLY = true,
	SP_ONLY = false,
	MP_ONLY = false
}

---@class command_flags
---@field ARCHIVE? boolean Should save the value
---@field LOCAL_ONLY? boolean Only the local player can run this command
---@field SP_ONLY? boolean This command can only be used in SP
---@field MP_ONLY? boolean This command can only be used in MP

---@param name string
---@param callback function Arguments are: (player_id, args)
---@param complition_callback function?
---@param help_text string?
---@param flags command_flags?
---@return table command
function Command.Add(name, callback, complition_callback, help_text, flags)
	assert(isstring(name), "bad argument 'name' for 'Command.Add'.\nExpected string got " .. type(name) .. "\nIn:")
	assert(isfunction(callback), "bad argument 'callback' for 'command.Add'.\nExpected function got " .. type(callback) .. "\nIn:")
	if complition_callback ~= nil then
		assert(isfunction(complition_callback), "bad argument 'complition_callback' for 'Command.Add'.\nExpected function got " .. type(complition_callback) .. "\nIn:")
	end
	if help_text ~= nil then
		assert(isstring(help_text), "bad argument 'help_text' for 'Command.Add'.\nExpected string got " .. type(help_text) .. "\nIn:")
	end
	if flags ~= nil then
		assert(istable(flags), "bad argument 'flags' for 'Command.Add'.\nExpected table got " .. type(flags) .. "\nIn:")
	end

	flags = flags or {}

	commands[name] = {
		callback = callback,
		complition_callback = complition_callback,
		help_text = help_text,
		flags = flags
	}

	return commands[name]
end

local last_save_time = 0
local function SaveConvars()
	local cvar_file = "# This file is automatically generated\n"
	for key, value in pairs(commands) do
		if value.flags.ARCHIVE then
			cvar_file = cvar_file .. key .. " \"" .. value.value .. "\"\n"
		end
	end

	local cfg_file = io.open("convars.cfg", "w")
	if cfg_file then
		cfg_file:write(cvar_file)
		last_save_time = os.time()
		cfg_file:close()
	end
end

local function LoadConfig(filename)
	local cfg_file = io.open(filename, "r")
	if cfg_file == nil then return end

	for line in cfg_file:lines() do
		if not string.startswith(line, "//") and not string.startswith(line, "#") then
			Command.Call(self.get_id(), line)
		end
	end

	cfg_file:close()
end

event.register_handler(menu_event.LuaInitFinished, "LoadCommands", function()
	LoadConfig("convars.cfg")
	LoadConfig("autoexec.cfg")

	initial_config_loaded = true
end)

local function ConVarCallback(player_id, args)
	local convar_name = args[1]

	if args[2] == nil then
		log_info(tostring(commands[convar_name].value))
		return
	end

	commands[convar_name].value = args[2]

	-- Don't save if we have already saved in the last 5 seconds
	if initial_config_loaded and os.time() - last_save_time > 5 then
		SaveConvars()
	end
end

---@param name string
---@param default_value string
---@param help_text string?
---@param flags command_flags?
---@return table convar
function ConVar.Add(name, default_value, help_text, flags)
	assert(isstring(name), "bad argument 'name' for 'ConVar.Add'.\nExpected string got " .. type(name) .. "\nIn:")
	assert(isstring(default_value), "bad argument 'default_value' for 'ConVar.Add'.\nExpected string got " .. type(default_value) .. "\nIn:")
	if help_text ~= nil then
		assert(isstring(help_text), "bad argument 'help_text' for 'ConVar.Add'.\nExpected string got " .. type(help_text) .. "\nIn:")
	end
	if flags ~= nil then
		assert(istable(flags), "bad argument 'flags' for 'ConVar.Add'.\nExpected table got " .. type(flags) .. "\nIn:")
	end

	flags = flags or default_convar_flags

	commands[name] = {
		callback = ConVarCallback,
		help_text = help_text,
		flags = flags,
		value = default_value,
		default_value = default_value
	}

	return commands[name]
end


---Turns command_string to command table
---@param command_string string
---@param allow_warnings boolean?
---@return table command_args
function Command.Parse(command_string, allow_warnings)
	-- Pasted from: https://stackoverflow.com/a/28664691
	local args = {}
	local spat, epat = [=[^(['"])]=], [=[(['"])$]=]
	local buf, quoted
	for str in string_gmatch(command_string,"%S+") do
		local squoted = str:match(spat)
		local equoted = str:match(epat)
		local escaped = str:match([=[(\*)['"]$]=])
		if squoted and not quoted and not equoted then
			buf, quoted = str, squoted
		elseif buf and equoted == quoted and #escaped % 2 == 0 then
			str, buf, quoted = buf .. ' ' .. str, nil, nil
		elseif buf then
			buf = buf .. ' ' .. str
		end
		if not buf then
			args[#args+1] = str:gsub(spat, ""):gsub(epat, "")
		end
	end
	if buf and allow_warnings then
		log_warning("Missing matching quote for "..buf)
	end

	return args
end

---@param player_id number Player that called this command
---@param cmd string The command as a string
---@param hide_input? boolean Don't show that we ran the command in the console
---@return boolean success
function Command.Call(player_id, cmd, hide_input)
	assert(isnumber(player_id), "bad argument 'player_id' for 'Command.Call'.\nExpected number got " .. type(player_id) .. "\nIn:")
	assert(isstring(cmd), "bad argument 'command' for 'Command.Call'.\nExpected string got " .. type(cmd) .. "\nIn:")

	if not hide_input then
		log_info("> " .. cmd)
	end

	local args = Command.Parse(cmd, true)
	local name = args[1]
	if name then
		if commands[name] then
			commands[name].callback(player_id, args)
			return true
		end
		log_warning("Command: " .. tostring(name) .. " not found")
	end
	return false
end


function Command.GetTable()
	return commands
end

